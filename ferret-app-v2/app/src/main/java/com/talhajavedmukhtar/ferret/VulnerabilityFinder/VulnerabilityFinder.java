package com.talhajavedmukhtar.ferret.VulnerabilityFinder;

import android.content.Context;
import android.os.AsyncTask;
import android.util.Log;

import com.talhajavedmukhtar.ferret.BannerGrabber.BannerGrabber;
import com.talhajavedmukhtar.ferret.BannerGrabber.BannerInterface;
import com.talhajavedmukhtar.ferret.CVESearcher.CVESearcher;
import com.talhajavedmukhtar.ferret.CVESearcher.CVESearcherInterface;
import com.talhajavedmukhtar.ferret.Model.Banner;
import com.talhajavedmukhtar.ferret.Model.DataItem;
import com.talhajavedmukhtar.ferret.Model.Host;
import com.talhajavedmukhtar.ferret.Model.VulnerabilityData;
import com.talhajavedmukhtar.ferret.Util.CVESearchHelper;
import com.talhajavedmukhtar.ferret.Util.Tags;
import com.talhajavedmukhtar.ferret.Util.Utils;

import java.util.ArrayList;

public class VulnerabilityFinder extends AsyncTask {
    private String TAG = Tags.makeTag("VulnerabilityFinder");

    private Host host;
    private FinderInterface finderInterface;
    private DataItem dataToBeSaved;

    private ArrayList<VulnerabilityData> vulnerabilityData;
    private Boolean vulnerable;

    private int cveSearched;
    private Boolean allBannersGrabbed;
    private int noOfBannersGrabbed;

    private Context context;

    private CVESearcher.Tuple<ArrayList<String>, ArrayList<String>> ident_descs;

    public VulnerabilityFinder(Context ctx, Host h) {
        context = ctx;
        host = h;

        vulnerabilityData = new ArrayList<>();
        vulnerable = false;

        cveSearched = 0;
        allBannersGrabbed = false;
        noOfBannersGrabbed = 0;
    }

    public CVESearcher.Tuple<ArrayList<String>, ArrayList<String>> getIdentDescs() {
        return ident_descs;
    }

    public void setIdentDescs(CVESearcher.Tuple<ArrayList<String>, ArrayList<String>> ident_descs) {
        this.ident_descs = ident_descs;
    }

    public void setFinderInterface(FinderInterface fInterface) {
        finderInterface = fInterface;
    }


    @Override
    protected Object doInBackground(Object[] objects) {
        final ArrayList<Banner> foundBanners = new ArrayList<>();
        Log.d(TAG, "Step 1 of Finding Vulnerabilities for " + host.getIpAddress());

        //start banner grabber execution
        BannerGrabber bannerGrabber = new BannerGrabber(context, host.getIpAddress(), host);
        BannerInterface bannerInterface = new BannerInterface() {
            @Override
            public void onFound(final Banner b) {
                final String softName = Utils.getProductFromBanner(b);
                final String version = Utils.getVersionFromBanner(b);
                if (softName == null) {
                    cveSearched += 1;
                    ArrayList<String> vulns = new ArrayList<>();
                    VulnerabilityData dataEntry = new VulnerabilityData(b, softName, version, vulns);
                    vulnerabilityData.add(dataEntry);

                    if (allBannersGrabbed && (cveSearched == noOfBannersGrabbed)) {
                        dataToBeSaved = new DataItem(host);
                        dataToBeSaved.setVulnerabilityData(vulnerabilityData);
                        dataToBeSaved.setBool(vulnerable);

                        publishProgress();
                    }
                } else {
                    final CVESearcher cveSearcher = new CVESearcher(context, softName, version);
                    cveSearcher.setCveSearcherInterface(new CVESearcherInterface() {
                        @Override
                        public void onCompletion(ArrayList<String> idents) {
                            cveSearched += 1;
                            Log.d(TAG, "host: " + host.getIpAddress() + " , cveSearched=" + Integer.toString(cveSearched) + " , noOfIdents=" + Integer.toString(idents.size()));
                            if (idents.size() != 0) {
                                setIdentDescs(cveSearcher.getIdentDescs());
//                                for(int i = 0; i < idents.size(); i++)
//                                {
//                                    Log.d( TAG,"idents" + idents.get(i));
//                                }


                                vulnerable = true;
                            }

                            VulnerabilityData dataEntry = new VulnerabilityData(b, softName, version, idents);
                            vulnerabilityData.add(dataEntry);

                            if (allBannersGrabbed && (cveSearched == noOfBannersGrabbed)) {
                                dataToBeSaved = new DataItem(host);
                                dataToBeSaved.setVulnerabilityData(vulnerabilityData);
                                dataToBeSaved.setBool(vulnerable);

                                publishProgress();
                            }
                        }
                    });
                    cveSearcher.execute();
                }

            }

            @Override
            public void onCompletion(ArrayList<Banner> banners) {
                allBannersGrabbed = true;
                noOfBannersGrabbed = banners.size();

                Log.d(TAG, "host: " + host.getIpAddress() + " , noOfBanners=" + Integer.toString(noOfBannersGrabbed));

                if (noOfBannersGrabbed == 0) {
                    dataToBeSaved = new DataItem(host);
                    dataToBeSaved.setVulnerabilityData(vulnerabilityData);
                    dataToBeSaved.setBool(vulnerable);

                    publishProgress();
                }
            }
        };
        bannerGrabber.setBannerInterface(bannerInterface);

        bannerGrabber.execute();

        return null;
    }

    public void logVuln(ArrayList<VulnerabilityData> vulnerabilityData) {
        for (int i = 0; i < vulnerabilityData.size(); i++) {

            ArrayList<String> vulnstodisplay = vulnerabilityData.get(i).getVulnerabilities();
            for (int j = 0; j < vulnstodisplay.size(); j++) {
                Log.d(TAG, "vulnerabilites detected:" + vulnstodisplay.get(j));
            }

        }
    }

    @Override
    protected void onProgressUpdate(Object[] values) {
        super.onProgressUpdate(values);

        finderInterface.onCompletion(dataToBeSaved);
    }
}
